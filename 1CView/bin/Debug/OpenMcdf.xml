<?xml version="1.0"?>
<doc>
    <assembly>
        <name>OpenMcdf</name>
    </assembly>
    <members>
        <member name="T:RBTree.RedBlack">
            <summary>
            A red-black tree must satisfy these properties:
            
            1. The root is black. 
            2. All leaves are black. 
            3. Red nodes can only have black children. 
            4. All paths from a node to its leaves contain the same number of black nodes.
            </summary>
        </member>
        <member name="M:RBTree.RedBlack.Add(System.IComparable,System.Object)">
            <summary>
             Add
             args: ByVal key As IComparable, ByVal data As Object
             key is object that implements IComparable interface
             performance tip: change to use use int type (such as the hashcode)
            </summary>
        </member>
        <member name="M:RBTree.RedBlack.RestoreAfterInsert(RBTree.RedBlackNode)">
            <summary>
             RestoreAfterInsert
             Additions to red-black trees usually destroy the red-black 
             properties. Examine the tree and restore. Rotations are normally 
             required to restore it
            </summary>
        </member>
        <member name="M:RBTree.RedBlack.RotateLeft(RBTree.RedBlackNode)">
            <summary>
             RotateLeft
             Rebalance the tree by rotating the nodes to the left
            </summary>
        </member>
        <member name="M:RBTree.RedBlack.RotateRight(RBTree.RedBlackNode)">
            <summary>
             RotateRight
             Rebalance the tree by rotating the nodes to the right
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.GetData(System.IComparable)" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.GetMinKey" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.GetMaxKey" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.GetMinValue" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.GetMaxValue" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.GetEnumerator" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.Keys" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.Values" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.Elements" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.IsEmpty" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.Remove(System.IComparable)" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.Delete(RBTree.RedBlackNode)" -->
        <member name="M:RBTree.RedBlack.RestoreAfterDelete(RBTree.RedBlackNode)">
            <summary>
             RestoreAfterDelete
             Deletions from red-black trees may destroy the red-black 
             properties. Examine the tree and restore. Rotations are normally 
             required to restore it
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.RemoveMin" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.RemoveMax" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.Clear" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.Size" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.Equals(System.Object)" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.GetHashCode" -->
        <!-- Badly formed XML comment ignored for member "M:RBTree.RedBlack.ToString" -->
        <member name="T:BinaryTrees.NodeList`1">
            <summary>
            Represents a collection of Node&lt;T&gt; instances.
            </summary>
            <typeparam name="T">The type of data held in the Node instances referenced by this class.</typeparam>
        </member>
        <member name="M:BinaryTrees.NodeList`1.FindByValue(`0)">
            <summary>
            Searches the NodeList for a Node containing a particular value.
            </summary>
            <param name="value">The value to search for.</param>
            <returns>The Node in the NodeList, if it exists; null otherwise.</returns>
        </member>
        <member name="T:BinaryTrees.BinarySearchTree`1">
            <summary>
            Represents a binary search tree.  A binary search tree is a binary tree whose nodes are arranged
            such that for any given node k, all nodes in k's left subtree have a value less than k, and all
            nodes in k's right subtree have a value greater than k.
            </summary>
            <typeparam name="T">The type of data stored in the binary tree nodes.</typeparam>
        </member>
        <member name="M:BinaryTrees.BinarySearchTree`1.Clear">
            <summary>
            Removes the contents of the BST
            </summary>
        </member>
        <member name="M:BinaryTrees.BinarySearchTree`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the contents of the BST to an appropriately-sized array of type T, using the Inorder
            traversal method.
            </summary>
        </member>
        <member name="M:BinaryTrees.BinarySearchTree`1.CopyTo(`0[],System.Int32,BinaryTrees.TraversalMethod)">
            <summary>
            Copies the contents of the BST to an appropriately-sized array of type T, using a specified
            traversal method.
            </summary>
        </member>
        <member name="M:BinaryTrees.BinarySearchTree`1.Add(`0)">
            <summary>
            Adds a new value to the BST.
            </summary>
            <param name="data">The data to insert into the BST.</param>
            <remarks>Adding a value already in the BST has no effect; that is, the SkipList is not
            altered, the Add() method simply exits.</remarks>
        </member>
        <member name="M:BinaryTrees.BinarySearchTree`1.Contains(`0)">
            <summary>
            Returns a Boolean, indicating if a specified value is contained within the BST.
            </summary>
            <param name="data">The data to search for.</param>
            <returns>True if data is found in the BST; false otherwise.</returns>
        </member>
        <member name="M:BinaryTrees.BinarySearchTree`1.TryFind(`0,`0@)">
            <summary>
            Returns a Boolean, indicating if a specified value is contained within the BST.
            </summary>
            <param name="data">The data to search for.</param>
            <returns>True if data is found in the BST; false otherwise.</returns>
        </member>
        <member name="M:BinaryTrees.BinarySearchTree`1.Remove(`0)">
            <summary>
            Attempts to remove the specified data element from the BST.
            </summary>
            <param name="data">The data to remove from the BST.</param>
            <returns>True if the element is found in the tree, and removed; false if the element is not
            found in the tree.</returns>
        </member>
        <member name="M:BinaryTrees.BinarySearchTree`1.GetEnumerator">
            <summary>
            Enumerates the BST's contents using inorder traversal.
            </summary>
            <returns>An enumerator that provides inorder access to the BST's elements.</returns>
        </member>
        <member name="M:BinaryTrees.BinarySearchTree`1.GetEnumerator(BinaryTrees.TraversalMethod)">
            <summary>
            Enumerates the BST's contents using a specified traversal method.
            </summary>
            <param name="TraversalMethod">The type of traversal to perform.</param>
            <returns>An enumerator that provides access to the BST's elements using a specified traversal technique.</returns>
        </member>
        <member name="P:BinaryTrees.BinarySearchTree`1.Preorder">
            <summary>
            Provides enumeration through the BST using preorder traversal.
            </summary>
        </member>
        <member name="P:BinaryTrees.BinarySearchTree`1.Inorder">
            <summary>
            Provides enumeration through the BST using inorder traversal.
            </summary>
        </member>
        <member name="P:BinaryTrees.BinarySearchTree`1.Postorder">
            <summary>
            Provides enumeration through the BST using postorder traversal.
            </summary>
        </member>
        <member name="P:BinaryTrees.BinarySearchTree`1.Count">
            <summary>
            Returns the number of elements in the BST.
            </summary>
        </member>
        <member name="T:RBTree.RedBlackException">
            <summary>
             The RedBlackException class distinguishes read black tree exceptions from .NET
             exceptions. 
            </summary>
        </member>
        <member name="T:OpenMcdf.Ver3SizeLimitReached">
            <summary>
            Action to implement when transaction support - sector
            has to be written to the underlying stream (see specs).
            </summary>
        </member>
        <member name="T:OpenMcdf.SectorCollection">
            <summary>
            Ad-hoc Heap Friendly sector collection to avoid using 
            large array that may create some problem to GC collection 
            (see http://www.simple-talk.com/dotnet/.net-framework/the-dangers-of-the-large-object-heap/ )
            </summary>
        </member>
        <member name="T:OpenMcdf.CFException">
            <summary>
            OpenMCDF base exception.
            </summary>
        </member>
        <member name="T:OpenMcdf.CFDisposedException">
            <summary>
            Raised when a data setter/getter method is invoked
            on a stream or storage object after the disposal of the owner
            compound file object.
            </summary>
        </member>
        <member name="T:OpenMcdf.CFFileFormatException">
            <summary>
            Raised when opening a file with invalid header
            or not supported COM/OLE Structured storage version.
            </summary>
        </member>
        <member name="T:OpenMcdf.CFItemNotFound">
            <summary>
            Raised when a named stream or a storage object
            are not found in a parent storage.
            </summary>
        </member>
        <member name="T:OpenMcdf.CFInvalidOperation">
            <summary>
            Raised when a method call is invalid for the current object state
            </summary>
        </member>
        <member name="T:OpenMcdf.CFDuplicatedItemException">
            <summary>
            Raised when trying to add a duplicated CFItem
            </summary>
            <remarks>
            Items are compared by name as indicated by specs.
            Two items with the same name CANNOT be added within 
            the same storage or sub-storage. 
            </remarks>
        </member>
        <member name="F:OpenMcdf.Header.OLE_CFS_SIGNATURE">
            <summary>
            Structured Storage signature
            </summary>
        </member>
        <member name="P:OpenMcdf.Header.FirstMiniFATSectorID">
            <summary>
            This integer field contains the starting sector number for the mini FAT
            </summary>
        </member>
        <member name="T:OpenMcdf.CFItem">
             <summary>
             Abstract base class for Structured Storage entities.
             </summary>
             <example>
             <code>
             
             const String STORAGE_NAME = "report.xls";
             CompoundFile cf = new CompoundFile(STORAGE_NAME);
            
             FileStream output = new FileStream("LogEntries.txt", FileMode.Create);
             TextWriter tw = new StreamWriter(output);
            
             // CFItem represents both storage and stream items
             VisitedEntryAction va = delegate(CFItem item)
             {
                  tw.WriteLine(item.Name);
             };
            
             cf.RootStorage.VisitEntries(va, true);
            
             tw.Close();
             
             </code>
             </example>
        </member>
        <member name="P:OpenMcdf.CFItem.Name">
            <summary>
            Get entity name
            </summary>
        </member>
        <member name="P:OpenMcdf.CFItem.Size">
            <summary>
            Size in bytes of the item. It has a valid value 
            only if entity is a stream, otherwise it is setted to zero.
            </summary>
        </member>
        <member name="P:OpenMcdf.CFItem.IsStorage">
            <summary>
            Return true if item is Storage
            </summary>
            <remarks>
            This check doesn't use reflection or runtime type information
            and doesn't suffer related performance penalties.
            </remarks>
        </member>
        <member name="P:OpenMcdf.CFItem.IsStream">
            <summary>
            Return true if item is a Stream
            </summary>
            <remarks>
            This check doesn't use reflection or runtime type information
            and doesn't suffer related performance penalties.
            </remarks>
        </member>
        <member name="P:OpenMcdf.CFItem.IsRoot">
            <summary>
            Return true if item is the Root Storage
            </summary>
            <remarks>
            This check doesn't use reflection or runtime type information
            and doesn't suffer related performance penalties.
            </remarks>
        </member>
        <member name="P:OpenMcdf.CFItem.CreationDate">
            <summary>
            Get/Set the Creation Date of the current item
            </summary>
        </member>
        <member name="P:OpenMcdf.CFItem.ModifyDate">
            <summary>
            Get/Set the Modify Date of the current item
            </summary>
        </member>
        <member name="P:OpenMcdf.CFItem.CLSID">
            <summary>
            Get/Set Object class Guid for Root and Storage entries.
            </summary>
        </member>
        <member name="T:BinaryTrees.Node`1">
            <summary>
            The Node&lt;T&gt; class represents the base concept of a Node for a tree or graph.  It contains
            a data item of type T, and a list of neighbors.
            </summary>
            <typeparam name="T">The type of data contained in the Node.</typeparam>
            <remarks>None of the classes in the SkmDataStructures2 namespace use the Node class directly;
            they all derive from this class, adding necessary functionality specific to each data structure.</remarks>
        </member>
        <member name="T:BinaryTrees.BinaryTreeNode`1">
            <summary>
            The BinaryTreeNode class represents a node in a binary tree, or a binary search tree.
            It has precisely two neighbors, which can be accessed via the Left and Right properties.
            </summary>
            <typeparam name="T">The type of data stored in the binary tree node.</typeparam>
        </member>
        <member name="T:OpenMcdf.StreamView">
            <summary>
            Stream decorator for a Sector or miniSector chain
            </summary>
        </member>
        <member name="T:OpenMcdf.CFSVersion">
            <summary>
            Binary File Format Version. Sector size  is 512 byte for version 3,
            4096 for version 4
            </summary>
        </member>
        <member name="F:OpenMcdf.CFSVersion.Ver_3">
            <summary>
            Compound file version 3 - The default and most common version available. Sector size 512 bytes, 2GB max file size.
            </summary>
        </member>
        <member name="F:OpenMcdf.CFSVersion.Ver_4">
            <summary>
            Compound file version 4 - Sector size is 4096 bytes. Using this version could bring some compatibility problem with existing applications.
            </summary>
        </member>
        <member name="T:OpenMcdf.UpdateMode">
            <summary>
            Update mode of the compound file.
            Default is ReadOnly.
            </summary>
        </member>
        <member name="F:OpenMcdf.UpdateMode.ReadOnly">
            <summary>
            ReadOnly update mode prevents overwriting
            of the opened file. 
            Data changes are allowed but they have to be 
            persisted on a different file when required.
            </summary>
        </member>
        <member name="F:OpenMcdf.UpdateMode.Update">
            <summary>
            Update mode allows subsequent data changing operations
            to be persisted directly on the opened file or stream
            using the <see cref="M:OpenMcdf.CompoundFile.Commit">Commit</see>
            method when required. Warning: this option may cause existing data loss if misused.
            </summary>
        </member>
        <member name="T:OpenMcdf.CompoundFile">
            <summary>
            Standard Microsoft&#169; Compound File implementation.
            It is also known as OLE/COM structured storage 
            and contains a hierarchy of storage and stream objects providing
            efficent storage of multiple kinds of documents in a single file.
            Version 3 and 4 of specifications are supported.
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.HEADER_DIFAT_ENTRIES_COUNT">
            <summary>
            Number of DIFAT entries in the header
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.SIZE_OF_SID">
            <summary>
            Sector ID Size (int)
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.FLUSHING_QUEUE_SIZE">
            <summary>
            Initial capacity of the flushing queue used
            to optimize commit writing operations
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.FLUSHING_BUFFER_MAX_SIZE">
            <summary>
            Maximum size of the flushing buffer used
            to optimize commit writing operations
            </summary>
        </member>
        <member name="M:OpenMcdf.CompoundFile.GetSectorSize">
            <summary>
            Returns the size of standard sectors switching on CFS version (3 or 4)
            </summary>
            <returns>Standard sector size</returns>
        </member>
        <member name="F:OpenMcdf.CompoundFile.DIFAT_SECTOR_FAT_ENTRIES_COUNT">
            <summary>
            Number of FAT entries in a DIFAT Sector
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.FAT_SECTOR_ENTRIES_COUNT">
            <summary>
            Sectors ID entries in a FAT Sector
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.sectorRecycle">
            <summary>
            Flag for sector recycling.
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.eraseFreeSectors">
            <summary>
            Flag for unallocated sector zeroing out.
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.header">
            <summary>
            CompoundFile header
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.sourceStream">
            <summary>
            Compound underlying stream. Null when new CF has been created.
            </summary>
        </member>
        <member name="M:OpenMcdf.CompoundFile.#ctor">
             <summary>
             Create a blank, version 3 compound file.
             Sector recycle is turned off to achieve the best reading/writing 
             performance in most common scenarios.
             </summary>
             <example>
             <code>
             
                 byte[] b = new byte[10000];
                 for (int i = 0; i &lt; 10000; i++)
                 {
                     b[i % 120] = (byte)i;
                 }
            
                 CompoundFile cf = new CompoundFile();
                 CFStream myStream = cf.RootStorage.AddStream("MyStream");
            
                 Assert.IsNotNull(myStream);
                 myStream.SetData(b);
                 cf.Save("MyCompoundFile.cfs");
                 cf.Close();
                 
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CompoundFile.#ctor(OpenMcdf.CFSVersion,System.Boolean,System.Boolean)">
             <summary>
             Create a new, blank, compound file.
             </summary>
             <param name="cfsVersion">Use a specific Compound File Version to set 512 or 4096 bytes sectors</param>
             <param name="sectorRecycle">If true, recycle unused sectors</param>
             <param name="eraseFreeSectors">If true, unallocated sectors will be overwritten with zeros</param>
             <example>
             <code>
             
                 byte[] b = new byte[10000];
                 for (int i = 0; i &lt; 10000; i++)
                 {
                     b[i % 120] = (byte)i;
                 }
            
                 CompoundFile cf = new CompoundFile(CFSVersion.Ver_4, true, true);
                 CFStream myStream = cf.RootStorage.AddStream("MyStream");
            
                 Assert.IsNotNull(myStream);
                 myStream.SetData(b);
                 cf.Save("MyCompoundFile.cfs");
                 cf.Close();
                 
             </code>
             </example>
             <remarks>
             Sector recycling reduces data writing performances but avoids space wasting in scenarios with frequently
             data manipulation of the same streams. The new compound file is open in Update mode.
             </remarks>
        </member>
        <member name="M:OpenMcdf.CompoundFile.#ctor(System.String)">
             <summary>
             Load an existing compound file.
             </summary>
             <param name="fileName">Compound file to read from</param>
             <example>
             <code>
             //A xls file should have a Workbook stream
             String filename = "report.xls";
            
             CompoundFile cf = new CompoundFile(filename);
             CFStream foundStream = cf.RootStorage.GetStream("Workbook");
            
             byte[] temp = foundStream.GetData();
            
             Assert.IsNotNull(temp);
            
             cf.Close();
             </code>
             </example>
             <remarks>
             File will be open in read-only mode: it has to be saved
             with a different filename. A wrapping implementation has to be provided 
             in order to remove/substitute an existing file. Version will be
             automatically recognized from the file. Sector recycle is turned off
             to achieve the best reading/writing performance in most common scenarios.
             </remarks>
        </member>
        <member name="M:OpenMcdf.CompoundFile.#ctor(System.String,OpenMcdf.UpdateMode,System.Boolean,System.Boolean)">
             <summary>
             Load an existing compound file.
             </summary>
             <param name="fileName">Compound file to read from</param>
             <param name="sectorRecycle">If true, recycle unused sectors</param>
             <param name="updateMode">Select the update mode of the underlying data file</param>
             <param name="eraseFreeSectors">If true, overwrite with zeros unallocated sectors</param>
             <example>
             <code>
             String srcFilename = "data_YOU_CAN_CHANGE.xls";
             
             CompoundFile cf = new CompoundFile(srcFilename, UpdateMode.Update, true, true);
            
             Random r = new Random();
            
             byte[] buffer = GetBuffer(r.Next(3, 4095), 0x0A);
            
             cf.RootStorage.AddStream("MyStream").SetData(buffer);
             
             //This will persist data to the underlying media.
             cf.Commit();
             cf.Close();
            
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CompoundFile.#ctor(System.IO.Stream,OpenMcdf.UpdateMode,System.Boolean,System.Boolean)">
             <summary>
             Load an existing compound file.
             </summary>
             <param name="stream">A stream containing a compound file to read</param>
             <param name="sectorRecycle">If true, recycle unused sectors</param>
             <param name="updateMode">Select the update mode of the underlying data file</param>
             <param name="eraseFreeSectors">If true, overwrite with zeros unallocated sectors</param>
             <example>
             <code>
             
             String filename = "reportREAD.xls";
               
             FileStream fs = new FileStream(filename, FileMode.Open);
             CompoundFile cf = new CompoundFile(fs, UpdateMode.ReadOnly, false, false);
             CFStream foundStream = cf.RootStorage.GetStream("Workbook");
            
             byte[] temp = foundStream.GetData();
            
             Assert.IsNotNull(temp);
            
             cf.Close();
            
             </code>
             </example>
             <exception cref="T:OpenMcdf.CFException">Raised when trying to open a non-seekable stream</exception>
             <exception cref="T:OpenMcdf.CFException">Raised stream is null</exception>
        </member>
        <member name="M:OpenMcdf.CompoundFile.#ctor(System.IO.Stream)">
             <summary>
             Load an existing compound file from a stream.
             </summary>
             <param name="stream">Streamed compound file</param>
             <example>
             <code>
             
             String filename = "reportREAD.xls";
               
             FileStream fs = new FileStream(filename, FileMode.Open);
             CompoundFile cf = new CompoundFile(fs);
             CFStream foundStream = cf.RootStorage.GetStream("Workbook");
            
             byte[] temp = foundStream.GetData();
            
             Assert.IsNotNull(temp);
            
             cf.Close();
            
             </code>
             </example>
             <exception cref="T:OpenMcdf.CFException">Raised when trying to open a non-seekable stream</exception>
             <exception cref="T:OpenMcdf.CFException">Raised stream is null</exception>
        </member>
        <member name="M:OpenMcdf.CompoundFile.Commit">
            <summary>
            Commit data changes since the previously commit operation
            to the underlying supporting stream or file on the disk.
            </summary>
            <remarks>
            This method can be used
            only if the supporting stream has been opened in 
            <see cref="T:OpenMcdf.UpdateMode">Update mode</see>.
            </remarks>
        </member>
        <member name="M:OpenMcdf.CompoundFile.Commit(System.Boolean)">
            <summary>
            Commit data changes since the previously commit operation
            to the underlying supporting stream or file on the disk.
            </summary>
            <param name="releaseMemory">If true, release loaded sectors to limit memory usage but reduces following read operations performance</param>
            <remarks>
            This method can be used only if 
            the supporting stream has been opened in 
            <see cref="T:OpenMcdf.UpdateMode">Update mode</see>.
            </remarks>
        </member>
        <member name="M:OpenMcdf.CompoundFile.Load(System.IO.Stream)">
            <summary>
            Load compound file from an existing stream.
            </summary>
            <param name="stream">Stream to load compound file from</param>
        </member>
        <member name="M:OpenMcdf.CompoundFile.SetMiniSectorChain(System.Collections.Generic.List{OpenMcdf.Sector})">
            <summary>
            Allocate space, setup sectors id and refresh header
            for the new or updated mini sector chain.
            </summary>
            <param name="sectorChain">The new MINI sector chain</param>
        </member>
        <member name="M:OpenMcdf.CompoundFile.SetNormalSectorChain(System.Collections.Generic.List{OpenMcdf.Sector})">
            <summary>
            Allocate space, setup sectors id and refresh header
            for the new or updated sector chain.
            </summary>
            <param name="sectorChain">The new or updated generic sector chain</param>
        </member>
        <member name="M:OpenMcdf.CompoundFile.CheckForLockSector">
            <summary>
            Check for transaction lock sector addition and mark it in the FAT.
            </summary>
        </member>
        <member name="M:OpenMcdf.CompoundFile.SetFATSectorChain(System.Collections.Generic.List{OpenMcdf.Sector})">
            <summary>
            Allocate space, setup sectors id and refresh header
            for the new or updated FAT sector chain.
            </summary>
            <param name="sectorChain">The new or updated generic sector chain</param>
        </member>
        <member name="M:OpenMcdf.CompoundFile.SetDIFATSectorChain(System.Collections.Generic.List{OpenMcdf.Sector})">
            <summary>
            Setup the DIFAT sector chain
            </summary>
            <param name="FATsectorChain">A FAT sector chain</param>
        </member>
        <member name="M:OpenMcdf.CompoundFile.GetDifatSectorChain">
            <summary>
            Get the DIFAT Sector chain
            </summary>
            <returns>A list of DIFAT sectors</returns>
        </member>
        <member name="M:OpenMcdf.CompoundFile.GetFatSectorChain">
            <summary>
            Get the FAT sector chain
            </summary>
            <returns>List of FAT sectors</returns>
        </member>
        <member name="M:OpenMcdf.CompoundFile.GetNormalSectorChain(System.Int32)">
            <summary>
            Get a standard sector chain
            </summary>
            <param name="secID">First SecID of the required chain</param>
            <returns>A list of sectors</returns>
        </member>
        <member name="M:OpenMcdf.CompoundFile.GetMiniSectorChain(System.Int32)">
            <summary>
            Get a mini sector chain
            </summary>
            <param name="secID">First SecID of the required chain</param>
            <returns>A list of mini sectors (64 bytes)</returns>
        </member>
        <member name="M:OpenMcdf.CompoundFile.GetSectorChain(System.Int32,OpenMcdf.SectorType)">
            <summary>
            Get a sector chain from a compound file given the first sector ID
            and the required sector type.
            </summary>
            <param name="secID">First chain sector's id </param>
            <param name="chainType">Type of Sectors in the required chain (mini sectors, normal sectors or FAT)</param>
            <returns>A list of Sectors as the result of their concatenation</returns>
        </member>
        <member name="M:OpenMcdf.CompoundFile.ResetDirectoryEntry(System.Int32)">
            <summary>
            Reset a directory entry setting it to StgInvalid in the Directory.
            </summary>
            <param name="sid">Sid of the directory to invalidate</param>
        </member>
        <member name="M:OpenMcdf.CompoundFile.LoadDirectories">
            <summary>
            Load directory entries from compound file. Header and FAT MUST be already loaded.
            </summary>
        </member>
        <member name="M:OpenMcdf.CompoundFile.CommitDirectory">
            <summary>
             Commit directory entries change on the Current Source stream
            </summary>
        </member>
        <member name="M:OpenMcdf.CompoundFile.Save(System.String)">
            <summary>
            Saves the in-memory image of Compound File to a file.
            </summary>
            <param name="fileName">File name to write the compound file to</param>
            <exception cref="T:OpenMcdf.CFException">Raised if destination file is not seekable</exception>
        </member>
        <member name="M:OpenMcdf.CompoundFile.Save(System.IO.Stream)">
             <summary>
             Saves the in-memory image of Compound File to a stream.
             </summary>        
             <remarks>
             Destination Stream must be seekable.
             </remarks>
             <param name="stream">The stream to save compound File to</param>
             <exception cref="T:OpenMcdf.CFException">Raised if destination stream is not seekable</exception>
             <exception cref="T:OpenMcdf.CFDisposedException">Raised if Compound File Storage has been already disposed</exception>
             <example>
             <code>
                MemoryStream ms = new MemoryStream(size);
            
                CompoundFile cf = new CompoundFile();
                CFStorage st = cf.RootStorage.AddStorage("MyStorage");
                CFStream sm = st.AddStream("MyStream");
            
                byte[] b = new byte[]{0x00,0x01,0x02,0x03};
            
                sm.SetData(b);
                cf.Save(ms);
                cf.Close();
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CompoundFile.FindFreeSectors(OpenMcdf.SectorType)">
            <summary>
            Scan FAT o miniFAT for free sectors to reuse.
            </summary>
            <param name="sType">Type of sector to look for</param>
            <returns>A stack of available sectors or minisectors already allocated</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:OpenMcdf.CompoundFile.AppendData(OpenMcdf.CFItem,System.Byte[])" -->
        <member name="M:OpenMcdf.CompoundFile.CheckFileLength">
            <summary>
            Check file size limit ( 2GB for version 3 )
            </summary>
        </member>
        <member name="M:OpenMcdf.CompoundFile.Close">
             <summary>
             Close the Compound File object <see cref="T:OpenMcdf.CompoundFile">CompoundFile</see> and
             free all associated resources (e.g. open file handle and allocated memory).
             <remarks>
             When the <see cref="T:OpenMcdf.CompoundFile.Close()">Close</see> method is called,
             all the associated stream and storage objects are invalidated:
             any operation invoked on them will produce a <see cref="T:OpenMcdf.CFDisposedException">CFDisposedException</see>.
             </remarks>
             </summary>
             <example>
             <code>
                const String FILENAME = "CompoundFile.cfs";
                CompoundFile cf = new CompoundFile(FILENAME);
            
                CFStorage st = cf.RootStorage.GetStorage("MyStorage");
                cf.Close();
            
                try
                {
                    byte[] temp = st.GetStream("MyStream").GetData();
                    
                    // The following line will fail because back-end object has been closed
                    Assert.Fail("Stream without media");
                }
                catch (Exception ex)
                {
                    Assert.IsTrue(ex is CFDisposedException);
                }
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CompoundFile.Dispose(System.Boolean)">
            <summary>
            When called from user code, release all resources, otherwise, in the case runtime called it,
            only unmanagd resources are released.
            </summary>
            <param name="disposing">If true, method has been called from User code, if false it's been called from .net runtime</param>
        </member>
        <member name="M:OpenMcdf.CompoundFile.ShrinkCompoundFile(System.IO.Stream)">
             <summary>
             Compress free space by removing unallocated sectors from compound file
             effectively reducing stream or file size.
             </summary>
             <remarks>
             Current implementation supports compression only for ver. 3 compound files.
             </remarks>
             <example>
             <code>
             
              //This code has been extracted from unit test
              
                String FILENAME = "MultipleStorage3.cfs";
            
                FileInfo srcFile = new FileInfo(FILENAME);
            
                File.Copy(FILENAME, "MultipleStorage_Deleted_Compress.cfs", true);
            
                CompoundFile cf = new CompoundFile("MultipleStorage_Deleted_Compress.cfs", UpdateMode.Update, true, true);
            
                CFStorage st = cf.RootStorage.GetStorage("MyStorage");
                st = st.GetStorage("AnotherStorage");
                
                Assert.IsNotNull(st);
                st.Delete("Another2Stream"); //17Kb
                cf.Commit();
                cf.Close();
            
                CompoundFile.ShrinkCompoundFile("MultipleStorage_Deleted_Compress.cfs");
            
                FileInfo dstFile = new FileInfo("MultipleStorage_Deleted_Compress.cfs");
            
                Assert.IsTrue(srcFile.Length > dstFile.Length);
            
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CompoundFile.ShrinkCompoundFile(System.String)">
             <summary>
             Remove unallocated sectors from compound file in order to reduce its size.
             </summary>
             <remarks>
             Current implementation supports compression only for ver. 3 compound files.
             </remarks>
             <example>
             <code>
             
              //This code has been extracted from unit test
              
                String FILENAME = "MultipleStorage3.cfs";
            
                FileInfo srcFile = new FileInfo(FILENAME);
            
                File.Copy(FILENAME, "MultipleStorage_Deleted_Compress.cfs", true);
            
                CompoundFile cf = new CompoundFile("MultipleStorage_Deleted_Compress.cfs", UpdateMode.Update, true, true);
            
                CFStorage st = cf.RootStorage.GetStorage("MyStorage");
                st = st.GetStorage("AnotherStorage");
                
                Assert.IsNotNull(st);
                st.Delete("Another2Stream"); //17Kb
                cf.Commit();
                cf.Close();
            
                CompoundFile.ShrinkCompoundFile("MultipleStorage_Deleted_Compress.cfs");
            
                FileInfo dstFile = new FileInfo("MultipleStorage_Deleted_Compress.cfs");
            
                Assert.IsTrue(srcFile.Length > dstFile.Length);
            
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CompoundFile.DoCompression(OpenMcdf.CFStorage,OpenMcdf.CFStorage)">
            <summary>
            Recursively clones valid structures, avoiding to copy free sectors.
            </summary>
            <param name="currSrcStorage">Current source storage to clone</param>
            <param name="currDstStorage">Current cloned destination storage</param>
        </member>
        <member name="P:OpenMcdf.CompoundFile.HasSourceStream">
            <summary>
            Return true if this compound file has been 
            loaded from an existing file or stream
            </summary>
        </member>
        <member name="P:OpenMcdf.CompoundFile.RootStorage">
             <summary>
             The entry point object that represents the 
             root of the structures tree to get or set storage or
             stream data.
             </summary>
             <example>
             <code>
             
                //Create a compound file
                string FILENAME = "MyFileName.cfs";
                CompoundFile ncf = new CompoundFile();
            
                CFStorage l1 = ncf.RootStorage.AddStorage("Storage Level 1");
            
                l1.AddStream("l1ns1");
                l1.AddStream("l1ns2");
                l1.AddStream("l1ns3");
                CFStorage l2 = l1.AddStorage("Storage Level 2");
                l2.AddStream("l2ns1");
                l2.AddStream("l2ns2");
            
                ncf.Save(FILENAME);
                ncf.Close();
             </code>
             </example>
        </member>
        <member name="T:RBTree.RedBlackNode">
            <summary>
             The RedBlackNode class encapsulates a node in the tree
            </summary>
        </member>
        <member name="P:RBTree.RedBlackNode.Key">
            <summary>
            Key
            </summary>
        </member>
        <member name="P:RBTree.RedBlackNode.Data">
            <summary>
            Data
            </summary>
        </member>
        <member name="P:RBTree.RedBlackNode.Color">
            <summary>
            Color
            </summary>
        </member>
        <member name="P:RBTree.RedBlackNode.Left">
            <summary>
            Left
            </summary>
        </member>
        <member name="P:RBTree.RedBlackNode.Right">
            <summary>
             Right
            </summary>
        </member>
        <member name="M:OpenMcdf.DirectoryEntry.fnv_hash(System.Byte[])">
            <summary>
            FNV hash, short for Fowler/Noll/Vo
            </summary>
            <param name="buffer"></param>
            <returns>(not warranted) unique hash for byte array</returns>
        </member>
        <member name="T:OpenMcdf.VisitedEntryAction">
             <summary>
             Action to apply to  visited items in the OLE structured storage
             </summary>
             <param name="item">Currently visited <see cref="T:OpenMcdf.CFItem">item</see></param>
             <example>
             <code>
             
             //We assume that xls file should be a valid OLE compound file
             const String STORAGE_NAME = "report.xls";
             CompoundFile cf = new CompoundFile(STORAGE_NAME);
            
             FileStream output = new FileStream("LogEntries.txt", FileMode.Create);
             TextWriter tw = new StreamWriter(output);
            
             VisitedEntryAction va = delegate(CFItem item)
             {
                 tw.WriteLine(item.Name);
             };
            
             cf.RootStorage.VisitEntries(va, true);
            
             tw.Close();
            
             </code>
             </example>
        </member>
        <member name="T:OpenMcdf.CFStorage">
            <summary>
            Storage entity that acts like a logic container for streams
            or substorages in a compound file.
            </summary>
        </member>
        <member name="M:OpenMcdf.CFStorage.#ctor(OpenMcdf.CompoundFile)">
            <summary>
            Create a new CFStorage
            </summary>
            <param name="compFile">The Storage Owner - CompoundFile</param>
        </member>
        <member name="M:OpenMcdf.CFStorage.#ctor(OpenMcdf.CompoundFile,OpenMcdf.IDirectoryEntry)">
            <summary>
            Create a CFStorage using an existing directory (previously loaded).
            </summary>
            <param name="compFile">The Storage Owner - CompoundFile</param>
            <param name="dirEntry">An existing Directory Entry</param>
        </member>
        <member name="M:OpenMcdf.CFStorage.AddStream(System.String)">
             <summary>
             Create a new child stream inside the current <see cref="T:OpenMcdf.CFStorage">storage</see>
             </summary>
             <param name="streamName">The new stream name</param>
             <returns>The new <see cref="T:OpenMcdf.CFStream">stream</see> reference</returns>
             <exception cref="T:OpenMcdf.CFDuplicatedItemException">Raised when adding an item with the same name of an existing one</exception>
             <exception cref="T:OpenMcdf.CFDisposedException">Raised when adding a stream to a closed compound file</exception>
             <exception cref="T:OpenMcdf.CFException">Raised when adding a stream with null or empty name</exception>
             <example>
             <code>
             
              String filename = "A_NEW_COMPOUND_FILE_YOU_CAN_WRITE_TO.cfs";
            
              CompoundFile cf = new CompoundFile();
            
              CFStorage st = cf.RootStorage.AddStorage("MyStorage");
              CFStream sm = st.AddStream("MyStream");
              byte[] b = Helpers.GetBuffer(220, 0x0A);
              sm.SetData(b);
            
              cf.Save(filename);
              
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CFStorage.GetStream(System.String)">
             <summary>
             Get a named <see cref="T:OpenMcdf.CFStream">stream</see> contained in the current storage if existing.
             </summary>
             <param name="streamName">Name of the stream to look for</param>
             <returns>A stream reference if existing</returns>
             <exception cref="T:OpenMcdf.CFDisposedException">Raised if trying to delete item from a closed compound file</exception>
             <exception cref="T:OpenMcdf.CFItemNotFound">Raised if item to delete is not found</exception>
             <example>
             <code>
             String filename = "report.xls";
            
             CompoundFile cf = new CompoundFile(filename);
             CFStream foundStream = cf.RootStorage.GetStream("Workbook");
            
             byte[] temp = foundStream.GetData();
            
             Assert.IsNotNull(temp);
            
             cf.Close();
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CFStorage.GetStorage(System.String)">
             <summary>
             Get a named storage contained in the current one if existing.
             </summary>
             <param name="storageName">Name of the storage to look for</param>
             <returns>A storage reference if existing.</returns>
             <exception cref="T:OpenMcdf.CFDisposedException">Raised if trying to delete item from a closed compound file</exception>
             <exception cref="T:OpenMcdf.CFItemNotFound">Raised if item to delete is not found</exception>
             <example>
             <code>
             
             String FILENAME = "MultipleStorage2.cfs";
             CompoundFile cf = new CompoundFile(FILENAME, UpdateMode.ReadOnly, false, false);
            
             CFStorage st = cf.RootStorage.GetStorage("MyStorage");
            
             Assert.IsNotNull(st);
             cf.Close();
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CFStorage.AddStorage(System.String)">
             <summary>
             Create new child storage directory inside the current storage.
             </summary>
             <param name="storageName">The new storage name</param>
             <returns>Reference to the new <see cref="T:OpenMcdf.CFStorage">storage</see></returns>
             <exception cref="T:OpenMcdf.CFDuplicatedItemException">Raised when adding an item with the same name of an existing one</exception>
             <exception cref="T:OpenMcdf.CFDisposedException">Raised when adding a storage to a closed compound file</exception>
             <exception cref="T:OpenMcdf.CFException">Raised when adding a storage with null or empty name</exception>
             <example>
             <code>
             
              String filename = "A_NEW_COMPOUND_FILE_YOU_CAN_WRITE_TO.cfs";
            
              CompoundFile cf = new CompoundFile();
            
              CFStorage st = cf.RootStorage.AddStorage("MyStorage");
              CFStream sm = st.AddStream("MyStream");
              byte[] b = Helpers.GetBuffer(220, 0x0A);
              sm.SetData(b);
            
              cf.Save(filename);
              
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CFStorage.VisitEntries(OpenMcdf.VisitedEntryAction,System.Boolean)">
             <summary>
             Visit all entities contained in the storage applying a user provided action
             </summary>
             <exception cref="T:OpenMcdf.CFDisposedException">Raised when visiting items of a closed compound file</exception>
             <param name="action">User <see cref="T:OpenMcdf.VisitedEntryAction">action</see> to apply to visited entities</param>
             <param name="recursive"> Visiting recursion level. True means substorages are visited recursively, false indicates that only the direct children of this storage are visited</param>
             <example>
             <code>
             const String STORAGE_NAME = "report.xls";
             CompoundFile cf = new CompoundFile(STORAGE_NAME);
            
             FileStream output = new FileStream("LogEntries.txt", FileMode.Create);
             TextWriter tw = new StreamWriter(output);
            
             VisitedEntryAction va = delegate(CFItem item)
             {
                 tw.WriteLine(item.Name);
             };
            
             cf.RootStorage.VisitEntries(va, true);
            
             tw.Close();
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CFStorage.Delete(System.String)">
            <summary>
            Remove an entry from the current storage and compound file.
            </summary>
            <param name="entryName">The name of the entry in the current storage to delete</param>
            <example>
            <code>
            cf = new CompoundFile("A_FILE_YOU_CAN_CHANGE.cfs", UpdateMode.Update, true, false);
            cf.RootStorage.Delete("AStream"); // AStream item is assumed to exist.
            cf.Commit(true);
            cf.Close();
            </code>
            </example>
            <exception cref="T:OpenMcdf.CFDisposedException">Raised if trying to delete item from a closed compound file</exception>
            <exception cref="T:OpenMcdf.CFItemNotFound">Raised if item to delete is not found</exception>
            <exception cref="T:OpenMcdf.CFException">Raised if trying to delete root storage</exception>
        </member>
        <member name="T:BinaryTrees.BinaryTree`1">
            <summary>
            Represents a binary tree.  This class provides access to the Root of the tree.  The developer
            must manually create the binary tree by adding descendents to the root.
            </summary>
            <typeparam name="T">The type of data stored in the binary tree's nodes.</typeparam>
        </member>
        <member name="M:BinaryTrees.BinaryTree`1.Clear">
            <summary>
            Clears out the contents of the binary tree.
            </summary>
        </member>
        <member name="M:OpenMcdf.Sector.Dispose(System.Boolean)">
            <summary>
            When called from user code, release all resources, otherwise, in the case runtime called it,
            only unmanagd resources are released.
            </summary>
            <param name="disposing">If true, method has been called from User code, if false it's been called from .net runtime</param>
        </member>
        <member name="T:OpenMcdf.CFMock">
            <summary>
            Used as internal template object for binary tree searches.
            </summary>
        </member>
        <member name="T:BinaryTrees.TraversalMethod">
            <summary>
            Provides the set of values by which a binary search tree can be enumerated.
            </summary>
        </member>
        <member name="T:RBTree.RedBlackEnumerator">
            <summary>
             The RedBlackEnumerator class returns the keys or data objects of the treap in
             sorted order. 
            </summary>
        </member>
        <member name="M:RBTree.RedBlackEnumerator.#ctor(RBTree.RedBlackNode,System.Boolean,System.Boolean)">
            <summary>
             Determine order, walk the tree and push the nodes onto the stack
            </summary>
        </member>
        <member name="M:RBTree.RedBlackEnumerator.HasMoreElements">
            <summary>
             HasMoreElements
            </summary>
        </member>
        <member name="M:RBTree.RedBlackEnumerator.NextElement">
            <summary>
             NextElement
            </summary>
        </member>
        <member name="M:RBTree.RedBlackEnumerator.MoveNext">
            <summary>
             MoveNext
             For .NET compatibility
            </summary>
        </member>
        <member name="P:RBTree.RedBlackEnumerator.Key">
            <summary>
            Key
            </summary>
        </member>
        <member name="P:RBTree.RedBlackEnumerator.Value">
            <summary>
            Data
            </summary>
        </member>
        <member name="T:OpenMcdf.CFStream">
            <summary>
            OLE structured storage <see cref="T:OpenMcdf.CFStream">stream</see> Object
            It is contained inside a Storage object in a file-directory
            relationship and indexed by its name.
            </summary>
        </member>
        <member name="M:OpenMcdf.CFStream.SetData(System.Byte[])">
            <summary>
            Set the data associated with the stream object.
            </summary>
            <example>
            <code>
               byte[] b = new byte[]{0x0,0x1,0x2,0x3};
               CompoundFile cf = new CompoundFile();
               CFStream myStream = cf.RootStorage.AddStream("MyStream");
               myStream.SetData(b);
            </code>
            </example>
            <param name="data">Data bytes to write to this stream</param>
        </member>
        <member name="M:OpenMcdf.CFStream.AppendData(System.Byte[])">
            <summary>
            Append the provided data to stream data.
            </summary>
            <example>
            <code>
               byte[] b = new byte[]{0x0,0x1,0x2,0x3};
               byte[] b2 = new byte[]{0x4,0x5,0x6,0x7};
               CompoundFile cf = new CompoundFile();
               CFStream myStream = cf.RootStorage.AddStream("MyStream");
               myStream.SetData(b); // here we could also have invoked .AppendData
               myStream.AppendData(b2);
               cf.Save("MyLargeStreamsFile.cfs);
               cf.Close();
            </code>
            </example>
            <param name="data">Data bytes to append to this stream</param>
            <remarks>
            This method allows user to create stream with more than 2GB of data, 
            appending data to the end of existing ones.
            Large streams (>2GB) are only supported by CFS version 4.
            Append data can also be invoked on streams with no data in order
            to simplify its use inside loops.
            </remarks>
        </member>
        <member name="M:OpenMcdf.CFStream.GetData">
            <summary>
            Get the data associated with the stream object.
            </summary>
            <example>
            <code>
                CompoundFile cf2 = new CompoundFile("AFileName.cfs");
                CFStream st = cf2.RootStorage.GetStream("MyStream");
                byte[] buffer = st.GetData();
            </code>
            </example>
            <returns>Array of byte containing stream data</returns>
            <exception cref="T:OpenMcdf.CFDisposedException">
            Raised when the owner compound file has been closed.
            </exception>
        </member>
        <member name="M:OpenMcdf.CFStream.GetData(System.Int64,System.Int32@)">
            <summary>
            Get <paramref name="count"/> bytes associated with the stream object, starting from
            a provided <paramref name="offset"/>. When method returns, count will contain the
            effective count of bytes read.
            </summary>
            <example>
            <code>
            CompoundFile cf = new CompoundFile("AFileName.cfs");
            CFStream st = cf.RootStorage.GetStream("MyStream");
            int count = 8;
            // The stream is supposed to have a length greater than offset + count
            byte[] data = st.GetData(20, ref count);  
            cf.Close();
            </code>
            </example>
            <returns>Array of byte containing stream data</returns>
            <exception cref="T:OpenMcdf.CFDisposedException">
            Raised when the owner compound file has been closed.
            </exception>
        </member>
        <member name="M:OpenMcdf.CFStream.CopyFrom(System.IO.Stream)">
            <summary>
            Copy data from an existing stream.
            </summary>
            <param name="input">A stream to read from</param>
            <remarks>
            Input stream is NOT closed after method invocation.
            </remarks>
        </member>
    </members>
</doc>
